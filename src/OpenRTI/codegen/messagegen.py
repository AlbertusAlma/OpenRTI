#!/usr/bin/python
#
# This file is part of OpenRTI.
#
# OpenRTI is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2.1 of the License, or
# (at your option) any later version.
#
# OpenRTI is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with OpenRTI.  If not, see <http://www.gnu.org/licenses/>.
#

class SourceStream(object):
    def __init__(self, stream):
        self.__stream = stream
        self.__indent = 0

    def pushIndent(self):
        self.__indent += 1

    def popIndent(self):
        self.__indent -= 1

    def write(self, data):
        self.__stream.write(data)

    def writeline(self, line = None):
        if line is not None:
            count = self.__indent
            while 0 < count:
                self.write('  ')
                count = count - 1
            self.write(line)
        self.write('\n')

    def writeCopyright(self):
        self.writeline('/* -*-c++-*- OpenRTI - Copyright (C) 2009-2011 Mathias Froehlich')
        self.writeline(' *')
        self.writeline(' *')
        self.writeline(' * This file is part of OpenRTI.')
        self.writeline(' *')
        self.writeline(' * OpenRTI is free software: you can redistribute it and/or modify')
        self.writeline(' * it under the terms of the GNU Lesser General Public License as published by')
        self.writeline(' * the Free Software Foundation, either version 2.1 of the License, or')
        self.writeline(' * (at your option) any later version.')
        self.writeline(' *')
        self.writeline(' * OpenRTI is distributed in the hope that it will be useful,')
        self.writeline(' * but WITHOUT ANY WARRANTY; without even the implied warranty of')
        self.writeline(' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the')
        self.writeline(' * GNU Lesser General Public License for more details.')
        self.writeline(' *')
        self.writeline(' * You should have received a copy of the GNU Lesser General Public License')
        self.writeline(' * along with OpenRTI.  If not, see <http://www.gnu.org/licenses/>.')
        self.writeline(' *')
        self.writeline(' * This file is autogenerated by messagegen.py. Do not edit!')
        self.writeline(' *')
        self.writeline(' */')
        self.writeline()


###############################################################################
class DataType(object):
    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

    def isMessage(self):
        return False

    def writeForwardDeclaration(self, sourceStream):
        pass

    def writeDeclaration(self, sourceStream):
        pass

    def writeImplementation(self, sourceStream):
        pass

    def writeComponent(self, component, sourceStream, messageEncoding):
        pass

###############################################################################
class CDataType(DataType):
    def __init__(self, name, encoding, ctype):
        DataType.__init__(self, name)
        self.__encoding = encoding
        self.__ctype = ctype

    def getEncoding(self):
        return self.__encoding

    def getTypeName(self):
        return self.__ctype

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        name = self.getName()
        typeName = self.getTypeName()
        if typeName == name:
            return
        sourceStream.writeline('typedef {typeName} {name};'.format(typeName = typeName, name = name))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeC' + component)(self, sourceStream)

###############################################################################
class EnumLabel(object):
    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

class EnumDataType(DataType):
    def __init__(self, name):
        DataType.__init__(self, name)
        self.__enumList = []

    def addEnum(self, name):
        self.__enumList.append(EnumLabel(name))

    def getEnumList(self):
        return self.__enumList

    def writeForwardDeclaration(self, sourceStream):
        # enums cannot be forward declared, so, emit the full definition
        sourceStream.writeline('enum {name} {{'.format(name = self.getName()))
        sourceStream.pushIndent()

        value = 0
        for enum in self.__enumList:
            value = value + 1
            if value == len(self.__enumList):
                sourceStream.writeline('{enum}'.format(enum = enum.getName()))
            else:
                sourceStream.writeline('{enum},'.format(enum = enum.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeEnum' + component)(self, sourceStream)


###############################################################################
class VectorDataType(DataType):
    def __init__(self, name, scalarTypeName):
        DataType.__init__(self, name)
        self.__scalarTypeName = scalarTypeName

    def getScalarTypeName(self):
        return self.__scalarTypeName

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        scalar = self.__scalarTypeName
        sourceStream.writeline('typedef std::vector<{scalar}> {name};'.format(scalar = scalar, name = self.getName()))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeVector' + component)(self, sourceStream)


###############################################################################
class SetDataType(DataType):
    def __init__(self, name, scalarTypeName):
        DataType.__init__(self, name)
        self.__scalarTypeName = scalarTypeName

    def getScalarTypeName(self):
        return self.__scalarTypeName

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        scalar = self.__scalarTypeName
        sourceStream.writeline('typedef std::set<{scalar}> {name};'.format(scalar = scalar, name = self.getName()))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeSet' + component)(self, sourceStream)


###############################################################################
class MapDataType(DataType):
    def __init__(self, name, keyTypeName, valueTypeName):
        DataType.__init__(self, name)
        self.__keyTypeName = keyTypeName
        self.__valueTypeName = valueTypeName

    def getKeyTypeName(self):
        return self.__keyTypeName

    def getValueTypeName(self):
        return self.__valueTypeName

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        keyTypeName = self.__keyTypeName
        valueTypeName = self.__valueTypeName
        sourceStream.writeline('typedef std::map<{keyTypeName}, {valueTypeName}> {name};'.format(keyTypeName = keyTypeName, valueTypeName = valueTypeName, name = self.getName()))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeMap' + component)(self, sourceStream)


###############################################################################
class PairDataType(DataType):
    def __init__(self, name, firstTypeName, secondTypeName):
        DataType.__init__(self, name)
        self.__firstTypeName = firstTypeName
        self.__secondTypeName = secondTypeName

    def getFirstTypeName(self):
        return self.__firstTypeName

    def getSecondTypeName(self):
        return self.__secondTypeName

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        name = self.getName()
        firstTypeName = self.__firstTypeName
        secondTypeName = self.__secondTypeName
        sourceStream.writeline('typedef std::pair<{first}, {second}> {name};'.format(first = firstTypeName, second = secondTypeName, name = name))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writePair' + component)(self, sourceStream)


###############################################################################
class StructField(object):
    def __init__(self, name, typeName):
        self.__name = name
        self.__typeName = typeName

    def getName(self):
        return self.__name

    def getLowerName(self):
        return self.__name[0].lower() + self.__name[1:len(self.__name)]

    def getUpperName(self):
        return self.__name[0].upper() + self.__name[1:len(self.__name)]

    def getMemberName(self):
        return '_' + self.getLowerName()

    def getTypeName(self):
        return self.__typeName

    def writeSetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        sourceStream.writeline('void set{upperName}(const {typeName}& value)'.format(upperName = upperName, typeName = typeName))
        sourceStream.writeline('{{ {prefix}{memberName} = value; }}'.format(memberName = memberName, prefix = valuePrefix))

    def writeGetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        sourceStream.writeline('{typeName}& get{upperName}()'.format(upperName = upperName, typeName = typeName))
        sourceStream.writeline('{{ return {prefix}{memberName}; }}'.format(memberName = memberName, prefix = valuePrefix))

    def writeConstGetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        sourceStream.writeline('const {typeName}& get{upperName}() const'.format(upperName = upperName, typeName = typeName))
        sourceStream.writeline('{{ return {prefix}{memberName}; }}'.format(memberName = memberName, prefix = valuePrefix))

    def writeMemberInstance(self, sourceStream):
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        sourceStream.writeline('{typeName} {memberName};'.format(typeName = typeName, memberName = memberName))

###############################################################################
class StructDataType(DataType):
    def __init__(self, name, parentTypeName = None):
        DataType.__init__(self, name)
        self.__parentTypeName = parentTypeName
        self.__fieldList = []
        self.__cow = False

    def setCopyOnWrite(self, cow):
        self.__cow = cow

    def getCopyOnWrite(self):
        return self.__cow

    def addField(self, name, typeName):
        self.__fieldList.append(StructField(name, typeName))

    def getFieldList(self):
        return self.__fieldList

    def getParentTypeName(self):
        return self.__parentTypeName

    def writeForwardDeclaration(self, sourceStream):
        sourceStream.writeline('class OPENRTI_API {name};'.format(name = self.getName()))

    def writeDeclaration(self, sourceStream):
        if self.getParentTypeName() is None:
            sourceStream.writeline('class OPENRTI_API {name} {{'.format(name = self.getName()))
        else:
            sourceStream.writeline('class OPENRTI_API {name} : public {parentTypeName} {{'.format(name = self.getName(), parentTypeName = self.getParentTypeName()))
        sourceStream.writeline('public:')
        sourceStream.pushIndent()

        if self.__cow:
            sourceStream.writeline('{name}() : '.format(name = self.getName()))
            sourceStream.writeline('  _impl(new Implementation)')
            sourceStream.writeline('{ }')
            valuePrefix = 'getImpl().'
            constValuePrefix = 'getConstImpl().'
        else:
            valuePrefix = ''
            constValuePrefix = ''

        for field in self.__fieldList:
            field.writeSetter(sourceStream, valuePrefix)
            field.writeGetter(sourceStream, valuePrefix)
            field.writeConstGetter(sourceStream, constValuePrefix)
            sourceStream.writeline()

        # sourceStream.writeline('{name}& swap({name}& rhs)'.format(name = self.getName()))
        # sourceStream.writeline('{')
        # if self.__cow:
        #     sourceStream.writeline('  _impl.swap(rhs._impl);')
        # else:
        #     for field in self.__fieldList:
        #         lowerName = field.getLowerName()
        #         sourceStream.writeline('  _{lowerName}.swap(rhs._{lowerName});'.format(lowerName = lowerName))
        # sourceStream.writeline('  return *this;')
        # sourceStream.writeline('}')

        sourceStream.writeline('bool operator==(const {name}& rhs) const'.format(name = self.getName()))
        sourceStream.writeline('{')
        for field in self.__fieldList:
            upperName = field.getUpperName()
            sourceStream.writeline('  if (get{upperName}() != rhs.get{upperName}()) return false;'.format(upperName = upperName))
        sourceStream.writeline('  return true;')
        sourceStream.writeline('}')
        sourceStream.writeline('bool operator<(const {name}& rhs) const'.format(name = self.getName()))
        sourceStream.writeline('{')
        for field in self.__fieldList:
            upperName = field.getUpperName()
            sourceStream.writeline('  if (get{upperName}() < rhs.get{upperName}()) return true;'.format(upperName = upperName))
            sourceStream.writeline('  if (rhs.get{upperName}() < get{upperName}()) return false;'.format(upperName = upperName))
        sourceStream.writeline('  return false;')
        sourceStream.writeline('}')
        sourceStream.writeline('bool operator!=(const {name}& rhs) const'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator==(rhs); }')
        sourceStream.writeline('bool operator>(const {name}& rhs) const'.format(name = self.getName()))
        sourceStream.writeline('{ return rhs.operator<(*this); }')
        sourceStream.writeline('bool operator>=(const {name}& rhs) const'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator<(rhs); }')
        sourceStream.writeline('bool operator<=(const {name}& rhs) const'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator>(rhs); }')

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()

        if self.__cow:
            sourceStream.writeline('struct OPENRTI_API Implementation : public Referenced {')
            sourceStream.pushIndent()

        for field in self.__fieldList:
            field.writeMemberInstance(sourceStream)

        if self.__cow:
            sourceStream.popIndent()
            sourceStream.writeline('};')
            sourceStream.writeline()
            sourceStream.writeline('const Implementation& getConstImpl() const')
            sourceStream.writeline('{')
            sourceStream.writeline('  return *_impl;')
            sourceStream.writeline('}')
            sourceStream.writeline()
            sourceStream.writeline('Implementation& getImpl()')
            sourceStream.writeline('{')
            sourceStream.writeline('  if (1 < Referenced::count(_impl.get()))')
            sourceStream.writeline('    _impl = new Implementation(*_impl);')
            sourceStream.writeline('  return *_impl;')
            sourceStream.writeline('}')
            sourceStream.writeline()
            sourceStream.writeline('SharedPtr<Implementation> _impl;')

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeStruct' + component)(self, sourceStream)


###############################################################################
class MessageDataType(StructDataType):
    def __init__(self, name, parentTypeName = None):
        StructDataType.__init__(self, name, parentTypeName)

    def isMessage(self):
        return True

    def writeForwardDeclaration(self, sourceStream):
        sourceStream.writeline('class {name};'.format(name = self.getName()))

    def writeDeclaration(self, sourceStream):
        if self.getParentTypeName() is None:
            sourceStream.writeline('class OPENRTI_API {name} {{'.format(name = self.getName()))
        else:
            sourceStream.writeline('class OPENRTI_API {name} : public {parentTypeName} {{'.format(name = self.getName(), parentTypeName = self.getParentTypeName()))
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('{name}();'.format(name = self.getName()))
        sourceStream.writeline('virtual ~{name}();'.format(name = self.getName()))

        sourceStream.writeline()
        sourceStream.writeline('virtual const char* getTypeName() const;')
        sourceStream.writeline('virtual void dispatch(AbstractMessageDispatcher& dispatcher);')
        sourceStream.writeline('virtual void dispatch(ConstAbstractMessageDispatcher& dispatcher) const;')
        sourceStream.writeline()

        for field in self.getFieldList():
            field.writeSetter(sourceStream, '')
            field.writeGetter(sourceStream, '')
            field.writeConstGetter(sourceStream, '')
            sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()

        for field in self.getFieldList():
            field.writeMemberInstance(sourceStream)

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

    def writeImplementation(self, sourceStream):
        sourceStream.writeline('{name}::{name}()'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('{name}::~{name}()'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('const char*')
        sourceStream.writeline('{name}::getTypeName() const'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  return "{name}";'.format(name = self.getName()))
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('void')
        sourceStream.writeline('{name}::dispatch(AbstractMessageDispatcher& dispatcher)'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  dispatcher.accept(*this);')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('void')
        sourceStream.writeline('{name}::dispatch(ConstAbstractMessageDispatcher& dispatcher) const'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  dispatcher.accept(*this);')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline()

###############################################################################
class MessageEncoding(object):
    def __init__(self, name):
        self.__name = name
        # Currently this is common, but as the first incompatible change starts
        # override this in the encodings
        self.__opcodeMap = {
            'ConnectionLostMessage' : 1,
            'CreateFederationExecutionRequestMessage' : 2,
            'CreateFederationExecutionResponseMessage' : 3,
            'DestroyFederationExecutionRequestMessage' : 4,
            'DestroyFederationExecutionResponseMessage' : 5,
            'EnumerateFederationExecutionsRequestMessage' : 6,
            'EnumerateFederationExecutionsResponseMessage' : 7,
            'InsertFederationExecutionMessage' : 8,
            'EraseFederationExecutionMessage' : 9,
            'JoinFederationExecutionRequestMessage' : 10,
            'JoinFederationExecutionResponseMessage' : 11,
            'ResignFederationExecutionRequestMessage' : 12,
            'JoinFederateNotifyMessage' : 14,
            'ResignFederateNotifyMessage' : 15,
            'UpdateFederationObjectModelRequestMessage' : 17,
            'RegisterFederationSynchronizationPointMessage' : 30,
            'RegisterFederationSynchronizationPointResponseMessage' : 31,
            'AnnounceSynchronizationPointMessage' : 32,
            'SynchronizationPointAchievedMessage' : 33,
            'FederationSynchronizedMessage' : 34,
            'EnableTimeRegulationRequestMessage' : 40,
            'EnableTimeRegulationResponseMessage' : 41,
            'DisableTimeRegulationRequestMessage' : 42,
            'CommitLowerBoundTimeStampMessage' : 43,
            'ChangeInteractionClassPublicationMessage' : 50,
            'ChangeObjectClassPublicationMessage' : 51,
            'ChangeInteractionClassSubscriptionMessage' : 52,
            'ChangeObjectClassSubscriptionMessage' : 53,
            'ObjectInstanceHandlesRequestMessage' : 60,
            'ObjectInstanceHandlesResponseMessage' : 61,
            'ReleaseMultipleObjectInstanceNameHandlePairsMessage' : 62,
            'ReserveObjectInstanceNameRequestMessage' : 63,
            'ReserveObjectInstanceNameResponseMessage' : 64,
            'ReserveMultipleObjectInstanceNameRequestMessage' : 65,
            'ReserveMultipleObjectInstanceNameResponseMessage' : 66,
            'InteractionMessage' : 80,
            'TimeStampedInteractionMessage' : 81,
            'InsertObjectInstanceMessage' : 90,
            'DeleteObjectInstanceMessage' : 91,
            'TimeStampedDeleteObjectInstanceMessage' : 92,
            # obsolete 'LocalDeleteObjectInstanceMessage' : 93,
            'DestroyObjectInstanceMessage' : 94,
            'AttributeUpdateMessage' : 94,
            'TimeStampedAttributeUpdateMessage' : 96,
            'RequestAttributeUpdateMessage' : 97,
            'RequestClassAttributeUpdateMessage' : 98
        }

    def getName(self):
        return self.__name

    def getMessageOpcode(self, messageName):
        if messageName in self.__opcodeMap:
            return self.__opcodeMap[messageName]
        else:
            return None

    def writeCEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        typeName = dataType.getTypeName()
        encoding = dataType.getEncoding()
        sourceStream.writeline('void write{name}(const {ctype}& value)'.format(name = name, ctype = typeName))
        sourceStream.writeline('{')
        if typeName == 'VariableLengthData':
            sourceStream.writeline('  writeSizeTCompressed(value.size());')
            sourceStream.writeline('  if (!value.empty())')
            sourceStream.writeline('    _networkBuffer.addBuffer(value);')
        else:
            sourceStream.writeline('  write{encoding}Compressed(value);'.format(encoding = encoding))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeCDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        typeName = dataType.getTypeName()
        encoding = dataType.getEncoding()
        sourceStream.writeline('void read{name}({ctype}& value)'.format(name = name, ctype = typeName))
        sourceStream.writeline('{')
        if typeName == 'VariableLengthData':
            sourceStream.writeline('  size_t size = readSizeTCompressed();')
            sourceStream.writeline('  value.resize(size);')
            sourceStream.writeline('  if (size)')
            sourceStream.writeline('    _networkBuffer.addBuffer(VariableLengthData(size));')
        else:
            sourceStream.writeline('  value = read{encoding}Compressed();'.format(encoding = encoding))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeCPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        typeName = dataType.getTypeName()
        encoding = dataType.getEncoding()
        if typeName == 'VariableLengthData':
            sourceStream.writeline('void readPayload{name}({ctype}& value)'.format(name = name, ctype = typeName))
            sourceStream.writeline('{')
            sourceStream.writeline('  if (!value.size())')
            sourceStream.writeline('    return;')
            sourceStream.writeline('  value = _networkBuffer[++_index];')
            sourceStream.writeline('}')
            sourceStream.writeline()
        else:
            # Note the const here, this is a hack to make that work somehow ...
            sourceStream.writeline('void readPayload{name}(const {ctype}& value)'.format(name = name, ctype = typeName))
            sourceStream.writeline('{')
            sourceStream.writeline('}')
            sourceStream.writeline()

    def writeEnumEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  switch (value) {')
        value = 0
        for enum in dataType.getEnumList():
            sourceStream.writeline('  case {enum}:'.format(enum = enum.getName()))
            sourceStream.writeline('    writeUInt32Compressed({value});'.format(value = value))
            sourceStream.writeline('    break;')
            value = value + 1
        sourceStream.writeline('  default:')
        sourceStream.writeline('    writeUInt32Compressed({value});'.format(value = value))
        sourceStream.writeline('    break;')
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEnumDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  switch (readUInt32Compressed()) {')
        value = 0
        for enum in dataType.getEnumList():
            sourceStream.writeline('  case {value}:'.format(value = value))
            sourceStream.writeline('    value = {enum};'.format(enum = enum.getName()))
            sourceStream.writeline('    break;')
            value = value + 1
        sourceStream.writeline('  default:')
        sourceStream.writeline('    value = {enum};'.format(enum = enum.getName()))
        sourceStream.writeline('    break;')
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEnumPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeVectorEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  writeSizeTCompressed(value.size());')
        sourceStream.writeline('  for ({name}::const_iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    write{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeVectorDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  value.resize(readSizeTCompressed());')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    read{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeVectorPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    readPayload{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeSetEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  writeSizeTCompressed(value.size());')
        sourceStream.writeline('  for ({name}::const_iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    write{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeSetDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  size_t size = readSizeTCompressed();')
        sourceStream.writeline('  for (; size != 0; --size) {')
        sourceStream.writeline('    {scalarName} scalar;'.format(scalarName = scalarName))
        sourceStream.writeline('    read{scalarName}(scalar);'.format(scalarName = scalarName))
        sourceStream.writeline('    value.insert(scalar);')
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeSetPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    readPayload{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeMapEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        keyTypeName = dataType.getKeyTypeName()
        valueTypeName = dataType.getValueTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  writeSizeTCompressed(value.size());')
        sourceStream.writeline('  for ({name}::const_iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    write{keyTypeName}(i->first);'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    write{valueTypeName}(i->second);'.format(valueTypeName = valueTypeName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeMapDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        keyTypeName = dataType.getKeyTypeName()
        valueTypeName = dataType.getValueTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  size_t size = readSizeTCompressed();')
        sourceStream.writeline('  for (; size != 0; --size) {')
        sourceStream.writeline('    {keyTypeName} key;'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    read{keyTypeName}(key);'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    read{valueTypeName}(value[key]);'.format(valueTypeName = valueTypeName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeMapPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        keyTypeName = dataType.getKeyTypeName()
        valueTypeName = dataType.getValueTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    readPayload{keyTypeName}(i->first);'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    readPayload{valueTypeName}(i->second);'.format(valueTypeName = valueTypeName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writePairEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        firstTypeName = dataType.getFirstTypeName()
        secondTypeName = dataType.getSecondTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  write{firstTypeName}(value.first);'.format(firstTypeName = firstTypeName))
        sourceStream.writeline('  write{secondTypeName}(value.second);'.format(secondTypeName = secondTypeName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePairDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        firstTypeName = dataType.getFirstTypeName()
        secondTypeName = dataType.getSecondTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  read{firstTypeName}(value.first);'.format(firstTypeName = firstTypeName))
        sourceStream.writeline('  read{secondTypeName}(value.second);'.format(secondTypeName = secondTypeName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePairPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        firstTypeName = dataType.getFirstTypeName()
        secondTypeName = dataType.getSecondTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  readPayload{firstTypeName}(value.first);'.format(firstTypeName = firstTypeName))
        sourceStream.writeline('  readPayload{secondTypeName}(value.second);'.format(secondTypeName = secondTypeName))
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeStructEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        for field in dataType.getFieldList():
            fieldName = field.getName()
            typeName = field.getTypeName()
            sourceStream.writeline('  write{typeName}(value.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeStructDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        for field in dataType.getFieldList():
            fieldName = field.getName()
            typeName = field.getTypeName()
            sourceStream.writeline('  read{typeName}(value.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeStructPayloadDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        for field in dataType.getFieldList():
            fieldName = field.getName()
            typeName = field.getTypeName()
            sourceStream.writeline('  readPayload{typeName}(value.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName))
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeEncoderDeclaration(self, messageMap, sourceStream):
        encodingName = self.getName()
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_' + encodingName + 'MessageEncoder_h')
        sourceStream.writeline('#define OpenRTI_' + encodingName + 'MessageEncoder_h')
        sourceStream.writeline()
        sourceStream.writeline('#include "AbstractMessageEncoder.h"')
        sourceStream.writeline('#include "EncodeDataStream.h"')
        sourceStream.writeline('#include "Export.h"')
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline('#include "NetworkBuffer.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageEncoder : public AbstractMessageEncoder {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline(encodingName + 'MessageEncoder();')
        sourceStream.writeline('virtual ~' + encodingName + 'MessageEncoder();')
        sourceStream.writeline()

        sourceStream.writeline('virtual const char* getName() const;')
        sourceStream.writeline()

        sourceStream.writeline('virtual void encodeMessage(NetworkBuffer& networkBuffer, const AbstractMessage& message);')
        sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()

        sourceStream.writeline('class DispatchFunctor;')
        sourceStream.writeline('class EncodeStream;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()
        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeEncoderImplementation(self, messageMap, sourceStream):
        encodingName = self.getName()
        sourceStream.writeCopyright()
        sourceStream.writeline()
        sourceStream.writeline('#include "' + encodingName + 'MessageEncoder.h"')
        sourceStream.writeline('#include "AbstractMessageEncoder.h"')
        sourceStream.writeline('#include "EncodeDataStream.h"')
        sourceStream.writeline('#include "Export.h"')
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageEncoder::EncodeStream : public EncodeDataStream {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('EncodeStream(VariableLengthData& variableLengthData, NetworkBuffer& networkBuffer) :')
        sourceStream.writeline('  EncodeDataStream(variableLengthData),')
        sourceStream.writeline('  _networkBuffer(networkBuffer)')
        sourceStream.writeline('{ }')

        for t in messageMap.getTypeList():
            t.writeComponent('Encoder', sourceStream, self)

        sourceStream.writeline('NetworkBuffer& _networkBuffer;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageEncoder::DispatchFunctor {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('DispatchFunctor(' + encodingName + 'MessageEncoder& encoder, NetworkBuffer& networkBuffer) :')
        sourceStream.writeline('  _encoder(encoder), _networkBuffer(networkBuffer)')
        sourceStream.writeline('{ }')
        sourceStream.writeline()

        sourceStream.writeline('template<typename M>')
        sourceStream.writeline('void operator()(const M& message) const')
        sourceStream.writeline('{ encode(_networkBuffer, message); }')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline('encode(NetworkBuffer& networkBuffer, const AbstractMessage& message) const')
        sourceStream.writeline('{')
        sourceStream.writeline('  throw RTIinternalError(L"Invalid message dispatched to encoder!");')
        sourceStream.writeline('}')
        sourceStream.writeline()

        for t in messageMap.getTypeList():
            messageName = t.getName()
            opcode = self.getMessageOpcode(messageName)
            if opcode is None:
                continue
            sourceStream.writeline('void')
            sourceStream.writeline('encode(NetworkBuffer& networkBuffer, const {messageName}& message) const'.format(messageName = messageName))
            sourceStream.writeline('{')
            sourceStream.pushIndent()
            sourceStream.writeline('EncodeDataStream headerStream(networkBuffer.addScratchBuffer());')
            sourceStream.writeline('EncodeStream encodeStream(networkBuffer.addScratchBuffer(), networkBuffer);')
            sourceStream.writeline('encodeStream.writeUInt16Compressed({opcode});'.format(opcode = opcode))
            sourceStream.writeline('encodeStream.write{messageName}(message);'.format(messageName = messageName))
            sourceStream.writeline('headerStream.writeUInt32BE(uint32_t(encodeStream.size()));')
            sourceStream.popIndent()
            sourceStream.writeline('}')
            sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline(encodingName + 'MessageEncoder& _encoder;')
        sourceStream.writeline('NetworkBuffer& _networkBuffer;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline(encodingName + 'MessageEncoder::' + encodingName + 'MessageEncoder()')
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline(encodingName + 'MessageEncoder::~' + encodingName + 'MessageEncoder()')
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('const char*')
        sourceStream.writeline(encodingName + 'MessageEncoder::getName() const')
        sourceStream.writeline('{')
        sourceStream.writeline('  return "' + encodingName + '";')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingName + 'MessageEncoder::encodeMessage(NetworkBuffer& networkBuffer, const AbstractMessage& message)')
        sourceStream.writeline('{')
        sourceStream.writeline('  FunctorConstMessageDispatcher<DispatchFunctor> dispatcher(DispatchFunctor(*this, networkBuffer));')
        sourceStream.writeline('  message.dispatch(dispatcher);')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()

    def writeDecoderDeclaration(self, messageMap, sourceStream):
        encodingName = self.getName()
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_' + encodingName + 'MessageDecoder_h')
        sourceStream.writeline('#define OpenRTI_' + encodingName + 'MessageDecoder_h')
        sourceStream.writeline()
        sourceStream.writeline('#include "AbstractMessageDecoder.h"')
        sourceStream.writeline('#include "DecodeDataStream.h"')
        sourceStream.writeline('#include "Export.h"')
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline('#include "NetworkBuffer.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageDecoder : public AbstractMessageDecoder {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline(encodingName + 'MessageDecoder();')
        sourceStream.writeline('virtual ~' + encodingName + 'MessageDecoder();')
        sourceStream.writeline()

        sourceStream.writeline('virtual const char* getName() const;')
        sourceStream.writeline()

        sourceStream.writeline('virtual SharedPtr<AbstractMessage> readMessage(NetworkBuffer& networkBuffer);')
        sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline('class DecodeStream;')
        sourceStream.writeline('class PayloadDecoder;')
        sourceStream.writeline('void decodePayload(const NetworkBuffer& networkBuffer);')
        sourceStream.writeline('void decodeBody(NetworkBuffer& networkBuffer);')

        sourceStream.writeline('SharedPtr<AbstractMessage> _message;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()
        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeDecoderImplementation(self, messageMap, sourceStream):
        encodingName = self.getName()
        sourceStream.writeCopyright()
        sourceStream.writeline('#include "' + encodingName + 'MessageDecoder.h"')
        sourceStream.writeline('#include "AbstractMessageDecoder.h"')
        sourceStream.writeline('#include "DecodeDataStream.h"')
        sourceStream.writeline('#include "Export.h"')
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline('#include "NetworkBuffer.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageDecoder::DecodeStream : public DecodeDataStream {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('DecodeStream(const VariableLengthData& variableLengthData, NetworkBuffer& networkBuffer) :')
        sourceStream.writeline('  DecodeDataStream(variableLengthData),')
        sourceStream.writeline('  _networkBuffer(networkBuffer)')
        sourceStream.writeline('{ }')

        for t in messageMap.getTypeList():
            t.writeComponent('Decoder', sourceStream, self)

        sourceStream.writeline('NetworkBuffer& _networkBuffer;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageDecoder::PayloadDecoder {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('PayloadDecoder(const NetworkBuffer& networkBuffer) :')
        sourceStream.writeline('  _networkBuffer(networkBuffer),')
        sourceStream.writeline('  _index(1)')
        sourceStream.writeline('{ }')

        for t in messageMap.getTypeList():
            t.writeComponent('PayloadDecoder', sourceStream, self)

        sourceStream.writeline('const NetworkBuffer& _networkBuffer;')
        sourceStream.writeline('size_t _index;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline(encodingName + 'MessageDecoder::' + encodingName + 'MessageDecoder()')
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline(encodingName + 'MessageDecoder::~' + encodingName + 'MessageDecoder()')
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('const char*')
        sourceStream.writeline(encodingName + 'MessageDecoder::getName() const')
        sourceStream.writeline('{')
        sourceStream.writeline('  return "' + encodingName + '";')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('SharedPtr<AbstractMessage>')
        sourceStream.writeline(encodingName + 'MessageDecoder::readMessage(NetworkBuffer& networkBuffer)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('switch (networkBuffer.size()) {')
        sourceStream.writeline('case 0:')
        sourceStream.writeline('  networkBuffer.addScratchBuffer().resize(4);')
        sourceStream.writeline('  return 0;')
        sourceStream.writeline('case 1:')
        sourceStream.writeline('  networkBuffer.addScratchBuffer().resize(networkBuffer[0].getUInt32BE(0));')
        sourceStream.writeline('  return 0;')
        sourceStream.writeline('case 2:')
        sourceStream.writeline('  decodeBody(networkBuffer);')
        sourceStream.writeline('  break;')
        sourceStream.writeline('default:')
        sourceStream.writeline('  decodePayload(networkBuffer);')
        sourceStream.writeline('  break;')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('if (!networkBuffer.complete())')
        sourceStream.writeline('  return 0;')
        sourceStream.writeline()
        sourceStream.writeline('return SharedPtr<AbstractMessage>().swap(_message);')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingName + 'MessageDecoder::decodePayload(const NetworkBuffer& networkBuffer)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('DecodeDataStream decodeStream(networkBuffer[1]);')
        sourceStream.writeline('uint16_t opcode = decodeStream.readUInt16Compressed();')
        sourceStream.writeline('PayloadDecoder payloadDecoder(networkBuffer);')
        sourceStream.writeline('switch (opcode) {')
        for t in messageMap.getTypeList():
            messageName = t.getName()
            opcode = self.getMessageOpcode(messageName)
            if opcode is None:
                continue
            sourceStream.writeline('case {opcode}:'.format(opcode = opcode))
            sourceStream.pushIndent()
            sourceStream.writeline('payloadDecoder.readPayload{messageName}(static_cast<{messageName}&>(*_message));'.format(messageName = messageName))
            sourceStream.writeline('break;')
            sourceStream.popIndent()
        sourceStream.writeline('default:')
        sourceStream.writeline('  break;')
        sourceStream.writeline('}')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingName + 'MessageDecoder::decodeBody(NetworkBuffer& networkBuffer)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('DecodeStream decodeStream(networkBuffer[1], networkBuffer);')
        sourceStream.writeline('uint16_t opcode = decodeStream.readUInt16Compressed();')
        sourceStream.writeline('switch (opcode) {')

        for t in messageMap.getTypeList():
            messageName = t.getName()
            opcode = self.getMessageOpcode(messageName)
            if opcode is None:
                continue
            sourceStream.writeline('case {opcode}:'.format(opcode = opcode))
            sourceStream.pushIndent()
            sourceStream.writeline('_message = new {messageName};'.format(messageName = messageName))
            sourceStream.writeline('decodeStream.read{messageName}(static_cast<{messageName}&>(*_message));'.format(messageName = messageName))
            sourceStream.writeline('break;')
            sourceStream.popIndent()

        sourceStream.writeline('default:')
        sourceStream.writeline('break;')
        sourceStream.writeline('}')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('} // namespace OpenRTI')

###############################################################################
# FIXME move actual value encodings to here

class TightBE1MessageEncoding(MessageEncoding):
    def __init__(self):
        MessageEncoding.__init__(self, 'TightBE1')

# class AlignedLE1MessageEncoding(MessageEncoding):
#     def __init__(self):
#         MessageEncoding.__init__(self, 'AlignedLE1')

# class AlignedBE1MessageEncoding(MessageEncoding):
#     def __init__(self):
#         MessageEncoding.__init__(self, 'AlignedBE1')


###############################################################################
class TypeMap(object):
    def __init__(self, node):
        self.__typeList = []
        self.__typeMap = {}

        while node:
            if node.type == 'element':
                if node.name == 'message':
                    message = MessageDataType(node.prop('type') + 'Message', 'AbstractMessage')
                    field = node.children
                    while field:
                        if field.type == 'element' and field.name == 'field':
                            message.addField(field.prop('name'), field.prop('type'))
                        field = field.next
                    self.addType(message)

                elif node.name == 'type':
                    typeName = node.prop('type')
                    if typeName == 'enum':
                        enum = EnumDataType(node.prop('name'))
                        enumerant = node.children
                        while enumerant:
                            if enumerant.type == 'element' and enumerant.name == 'enumerant':
                                enum.addEnum(enumerant.prop('name'))
                            enumerant = enumerant.next
                        self.addType(enum)

                    elif typeName == 'vector':
                        self.addType(VectorDataType(node.prop('name'), node.prop('scalar')))

                    elif typeName == 'set':
                        self.addType(SetDataType(node.prop('name'), node.prop('scalar')))

                    elif typeName == 'map':
                        self.addType(MapDataType(node.prop('name'), node.prop('key'), node.prop('value')))

                    elif typeName == 'pair':
                        self.addType(PairDataType(node.prop('name'), node.prop('first'), node.prop('second')))

                    elif typeName == 'struct':
                        struct = StructDataType(node.prop('name'))
                        struct.setCopyOnWrite(node.prop('copyOnWrite') == 'true')
                        field = node.children
                        while field:
                            if field.type == 'element' and field.name == 'field':
                                struct.addField(field.prop('name'), field.prop('type'))
                            field = field.next
                        self.addType(struct)
                    else:
                        dataType = CDataType(node.prop('name'), node.prop('encoding'), node.prop('ctype'))
                        self.addType(dataType)
            node = node.next

    def addType(self, t):
        self.__typeList.append(t)
        self.__typeMap[t.getName()] = t

    def getTypeList(self):
        return self.__typeList

    def writeDeclaration(self, sourceStream):
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_Message_h')
        sourceStream.writeline('#define OpenRTI_Message_h')
        sourceStream.writeline()
        sourceStream.writeline('#include <map>')
        sourceStream.writeline('#include <set>')
        sourceStream.writeline('#include <vector>')
        sourceStream.writeline('#include "AbstractMessage.h"')
        sourceStream.writeline('#include "AbstractMessageDispatcher.h"')
        sourceStream.writeline('#include "Handle.h"')
        sourceStream.writeline('#include "VariableLengthData.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()
        for t in self.__typeList:
            t.writeForwardDeclaration(sourceStream)
        sourceStream.writeline()
        for t in self.__typeList:
            t.writeDeclaration(sourceStream)
        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeImplementation(self, sourceStream):
        sourceStream.writeCopyright()
        sourceStream.writeline()
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline()
        sourceStream.writeline('#include "AbstractMessage.h"')
        sourceStream.writeline('#include "AbstractMessageDispatcher.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()
        for t in self.__typeList:
            t.writeImplementation(sourceStream)
        sourceStream.writeline('} // namespace OpenRTI')

    def writeDispatcher(self, sourceStream):
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_AbstractMessageDispatcher_h')
        sourceStream.writeline('#define OpenRTI_AbstractMessageDispatcher_h')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()
        sourceStream.writeline('class AbstractMessage;')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            t.writeForwardDeclaration(sourceStream)

        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL AbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('virtual ~AbstractMessageDispatcher() {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept({name}&) = 0;'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('template<typename T>')
        sourceStream.writeline('class OPENRTI_LOCAL FunctorMessageDispatcher : public AbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('FunctorMessageDispatcher(const T& t) : _t(t) {}')
        sourceStream.writeline('virtual ~FunctorMessageDispatcher() {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept({name}& message) {{ _t(message); }}'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline('const T& _t;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ConstAbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('virtual ~ConstAbstractMessageDispatcher() {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept(const {name}&) = 0;'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('template<typename T>')
        sourceStream.writeline('class OPENRTI_LOCAL FunctorConstMessageDispatcher : public ConstAbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('FunctorConstMessageDispatcher(const T& t) : _t(t) {}')
        sourceStream.writeline('virtual ~FunctorConstMessageDispatcher() {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept(const {name}& message) {{ _t(message); }}'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline('const T& _t;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeEncoderDeclaration(self, sourceStream, messageEncoding):
        messageEncoding.writeEncoderDeclaration(self, sourceStream)

    def writeEncoderImplementation(self, sourceStream, messageEncoding):
        messageEncoding.writeEncoderImplementation(self, sourceStream)

    def writeDecoderDeclaration(self, sourceStream, messageEncoding):
        messageEncoding.writeDecoderDeclaration(self, sourceStream)

    def writeDecoderImplementation(self, sourceStream, messageEncoding):
        messageEncoding.writeDecoderImplementation(self, sourceStream)


# The main application

import sys
import getopt
import libxml2

messageDefinitionFile = 'codegen/Message.xml'
outputMode = ''

# try:
(args, trail) = getopt.getopt(sys.argv[1:], 'm:O:')
# except Exception,e:
#     show_usage()

for (arg, val) in args:
    if arg == '-m':
        messageDefinitionFile = val
    elif arg == '-O':
        outputMode = val

# read the xml document describing the types
#doc = libxml2.readFile(messageDefinitionFile, None,
#    libxml2.XML_PARSE_DTDLOAD +
#    libxml2.XML_PARSE_DTDVALID +
#    libxml2.XML_PARSE_NOBLANKS)
doc = libxml2.readFile(messageDefinitionFile, None, libxml2.XML_PARSE_NOBLANKS)
rootElement = doc.getRootElement()
typeMap = TypeMap(rootElement.children)
doc.freeDoc()

# These are the output modes for debugging specific stages
if outputMode == 'MessageDeclaration':
    typeMap.writeDeclaration(SourceStream(sys.stdout))
elif outputMode == 'MessageImplementation':
    typeMap.writeImplementation(SourceStream(sys.stdout))
elif outputMode == 'MessageDispatcher':
    typeMap.writeDispatcher(SourceStream(sys.stdout))
elif outputMode == 'MessageEncoder':
    typeMap.writeEncoder(SourceStream(sys.stdout), messageEncoding)
elif outputMode == 'MessageDecoder':
    typeMap.writeDecoder(SourceStream(sys.stdout), messageEncoding)
else:
    # This is the shortcut for 'just do all output into the current directory'
    typeMap.writeDeclaration(SourceStream(open('Message.h', 'w+')))
    typeMap.writeImplementation(SourceStream(open('Message.cpp', 'w+')))
    typeMap.writeDispatcher(SourceStream(open('AbstractMessageDispatcher.h', 'w+')))

    messageEncoding = TightBE1MessageEncoding()
    typeMap.writeEncoderDeclaration(SourceStream(open('TightBE1MessageEncoder.h', 'w+')), messageEncoding)
    typeMap.writeEncoderImplementation(SourceStream(open('TightBE1MessageEncoder.cpp', 'w+')), messageEncoding)
    typeMap.writeDecoderDeclaration(SourceStream(open('TightBE1MessageDecoder.h', 'w+')), messageEncoding)
    typeMap.writeDecoderImplementation(SourceStream(open('TightBE1MessageDecoder.cpp', 'w+')), messageEncoding)

